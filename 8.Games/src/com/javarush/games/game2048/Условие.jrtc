taskKey="com.javarush.games.game2048.part06"\n\nИгра 2048 (6/18)

Уже намного лучше. Но, думаю, мы можем больше. Давай раскрасим клетки с одинаковыми значениями в одинаковые цвета.

Для этого напишем метод setCellColoredNumber, который будет принимать в качестве параметров координаты клетки
и ее значение, и :
- вычислять цвет клетки (используя метод getColorByValue, который описан ниже),
- отображать значение и цвет клетки на игровом поле.

Для вычисления цвета реализуем вспомогательный метод getColorByValue, который будет возвращать цвет в зависимости
от переданного в метод значения клетки. Например, если мы передаем в метод 2, то он возвращает Color.BLUE и т.п.
Цвета клеток для разных чисел должны быть разные, а для одинаковых - одинаковые.
Числа, которые могут находиться в матрице gameField: 0, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048.

Для отображения значения и цвета клетки с координатами x и y на игровом поле нам на помощь придет специальный метод
setCellValueEx(int x, int y, Color cellColor, String value) класса Game.
Воспользуйся им, чтобы изменить цвет и значение клетки одновременно.
Значение 0 на игровом поле отображать не нужно: вместо него мы видим пустую клетку. Поэтому для ячеек со значением 0
просто передай в метод setCellValueEx() пустую строку.

И последний штрих: в методе drawScene() замени вызов метода setCellColor() на setCellColoredNumber().

Примечания:
1. Для наглядности пустые клетки в примерах будут обозначены нулями.
2. Координаты матрицы должны соответствовать отображаемым координатам.

Пример:
Матрица: {
{2, 4, 8, 16},
{32, 64, 128, 256},
{512, 1024, 2048, 0},
{2, 4, 8, 16}
}
Соответствующее отображение:
!!!Картинка!!!!
Чтобы это реализовать, при установке значения игровому полю используй инвертированные координаты матрицы.
Например, для установки значения клетке с координатами (х, у) используй значение матрицы gameField[y][x].

Чтобы лучше понять, о чем идет речь, запусти отрисовку этой матрицы, сначала используя gameField[y][x], а затем — gameField[х][у].


Требования:
1.	В классе Game2048 должен быть создан приватный метод Color getColorByValue(int value). Он должен возвращать цвет клетки по ее значению.
2.	В классе Game2048 должен быть создан приватный метод void setCellColoredNumber(int x, int y, int value).
3.	Метод setCellColoredNumber(int, int, int) должен вызывать метод getColorByValue(int).
4.	Метод setCellColoredNumber(int, int, int) должен вызывать метод setCellValueEx(int, int, Color, String).
5.	Метод setCellColoredNumber(int, int, int) должен изменять цвет плитки в зависимости от ее значения.
6.	Метод setCellColoredNumber(int, int, int) не должен отображать значение плитки на экране, если оно равно 0.
7.	В методе drawScene() должен быть заменен вызов метода setCellColor(int, int, Color) на setCellColoredNumber(int, int, int), чтобы значения и цвета плиток игрового поля на экране соответствовали значениям в матрице gameField.


Игра 2048 (6/18)

Уже намного лучше. Но, думаю, мы можем больше. Давай раскрасим клетки с одинаковыми значениями в одинаковые цвета.

Для этого напишем метод setCellColoredNumber, который будет принимать в качестве параметров координаты клетки
и ее значение, и :
- вычислять цвет клетки (используя метод getColorByValue, который описан ниже),
- отображать значение и цвет клетки на игровом поле.

Для вычисления цвета реализуем вспомогательный метод getColorByValue, который будет возвращать цвет в зависимости
от переданного в метод значения клетки. Например, если мы передаем в метод 2, то он возвращает Color.BLUE и т.п.
Цвета клеток для разных чисел должны быть разные, а для одинаковых - одинаковые.
Числа, которые могут находиться в матрице gameField: 0, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048.

Для отображения значения и цвета клетки с координатами x и y на игровом поле нам на помощь придет специальный метод
setCellValueEx(int x, int y, Color cellColor, String value) класса Game.
Воспользуйся им, чтобы изменить цвет и значение клетки одновременно.
Значение 0 на игровом поле отображать не нужно: вместо него мы видим пустую клетку. Поэтому для ячеек со значением 0
просто передай в метод setCellValueEx() пустую строку.

И последний штрих: в методе drawScene() замени вызов метода setCellColor() на setCellColoredNumber().

Примечания:
1. Для наглядности пустые клетки в примерах будут обозначены нулями.
2. Координаты матрицы должны соответствовать отображаемым координатам.

Пример:
Матрица: {
{2, 4, 8, 16},
{32, 64, 128, 256},
{512, 1024, 2048, 0},
{2, 4, 8, 16}
}
Соответствующее отображение:
!!!Картинка!!!!
Чтобы это реализовать, при установке значения игровому полю используй инвертированные координаты матрицы.
Например, для установки значения клетке с координатами (х, у) используй значение матрицы gameField[y][x].

Чтобы лучше понять, о чем идет речь, запусти отрисовку этой матрицы, сначала используя gameField[y][x], а затем — gameField[х][у].



Игра 2048 (6/18)

Уже намного лучше. Но, думаю, мы можем больше. Давай раскрасим клетки с одинаковыми значениями в одинаковые цвета.

Для этого напишем метод setCellColoredNumber, который будет принимать в качестве параметров координаты клетки
и ее значение, и :
- вычислять цвет клетки (используя метод getColorByValue, который описан ниже),
- отображать значение и цвет клетки на игровом поле.

Для вычисления цвета реализуем вспомогательный метод getColorByValue, который будет возвращать цвет в зависимости
от переданного в метод значения клетки. Например, если мы передаем в метод 2, то он возвращает Color.BLUE и т.п.
Цвета клеток для разных чисел должны быть разные, а для одинаковых - одинаковые.
Числа, которые могут находиться в матрице gameField: 0, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048.

Для отображения значения и цвета клетки с координатами x и y на игровом поле нам на помощь придет специальный метод
setCellValueEx(int x, int y, Color cellColor, String value) класса Game.
Воспользуйся им, чтобы изменить цвет и значение клетки одновременно.
Значение 0 на игровом поле отображать не нужно: вместо него мы видим пустую клетку. Поэтому для ячеек со значением 0
просто передай в метод setCellValueEx() пустую строку.

И последний штрих: в методе drawScene() замени вызов метода setCellColor() на setCellColoredNumber().

Примечания:
1. Для наглядности пустые клетки в примерах будут обозначены нулями.
2. Координаты матрицы должны соответствовать отображаемым координатам.

Пример:
Матрица: {
{2, 4, 8, 16},
{32, 64, 128, 256},
{512, 1024, 2048, 0},
{2, 4, 8, 16}
}
Соответствующее отображение:
!!!Картинка!!!!
Чтобы это реализовать, при установке значения игровому полю используй инвертированные координаты матрицы.
Например, для установки значения клетке с координатами (х, у) используй значение матрицы gameField[y][x].

Чтобы лучше понять, о чем идет речь, запусти отрисовку этой матрицы, сначала используя gameField[y][x], а затем — gameField[х][у].



Игра 2048 (6/18)

Уже намного лучше. Но, думаю, мы можем больше. Давай раскрасим клетки с одинаковыми значениями в одинаковые цвета.

Для этого напишем метод setCellColoredNumber, который будет принимать в качестве параметров координаты клетки
и ее значение, и :
- вычислять цвет клетки (используя метод getColorByValue, который описан ниже),
- отображать значение и цвет клетки на игровом поле.

Для вычисления цвета реализуем вспомогательный метод getColorByValue, который будет возвращать цвет в зависимости
от переданного в метод значения клетки. Например, если мы передаем в метод 2, то он возвращает Color.BLUE и т.п.
Цвета клеток для разных чисел должны быть разные, а для одинаковых - одинаковые.
Числа, которые могут находиться в матрице gameField: 0, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048.

Для отображения значения и цвета клетки с координатами x и y на игровом поле нам на помощь придет специальный метод
setCellValueEx(int x, int y, Color cellColor, String value) класса Game.
Воспользуйся им, чтобы изменить цвет и значение клетки одновременно.
Значение 0 на игровом поле отображать не нужно: вместо него мы видим пустую клетку. Поэтому для ячеек со значением 0
просто передай в метод setCellValueEx() пустую строку.

И последний штрих: в методе drawScene() замени вызов метода setCellColor() на setCellColoredNumber().

Примечания:
1. Для наглядности пустые клетки в примерах будут обозначены нулями.
2. Координаты матрицы должны соответствовать отображаемым координатам.

Пример:
Матрица: {
{2, 4, 8, 16},
{32, 64, 128, 256},
{512, 1024, 2048, 0},
{2, 4, 8, 16}
}
Соответствующее отображение:
!!!Картинка!!!!
Чтобы это реализовать, при установке значения игровому полю используй инвертированные координаты матрицы.
Например, для установки значения клетке с координатами (х, у) используй значение матрицы gameField[y][x].

Чтобы лучше понять, о чем идет речь, запусти отрисовку этой матрицы, сначала используя gameField[y][x], а затем — gameField[х][у].



Игра 2048 (6/18)

Уже намного лучше. Но, думаю, мы можем больше. Давай раскрасим клетки с одинаковыми значениями в одинаковые цвета.

Для этого напишем метод setCellColoredNumber, который будет принимать в качестве параметров координаты клетки
и ее значение, и :
- вычислять цвет клетки (используя метод getColorByValue, который описан ниже),
- отображать значение и цвет клетки на игровом поле.

Для вычисления цвета реализуем вспомогательный метод getColorByValue, который будет возвращать цвет в зависимости
от переданного в метод значения клетки. Например, если мы передаем в метод 2, то он возвращает Color.BLUE и т.п.
Цвета клеток для разных чисел должны быть разные, а для одинаковых - одинаковые.
Числа, которые могут находиться в матрице gameField: 0, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048.

Для отображения значения и цвета клетки с координатами x и y на игровом поле нам на помощь придет специальный метод
setCellValueEx(int x, int y, Color cellColor, String value) класса Game.
Воспользуйся им, чтобы изменить цвет и значение клетки одновременно.
Значение 0 на игровом поле отображать не нужно: вместо него мы видим пустую клетку. Поэтому для ячеек со значением 0
просто передай в метод setCellValueEx() пустую строку.

И последний штрих: в методе drawScene() замени вызов метода setCellColor() на setCellColoredNumber().

Примечания:
1. Для наглядности пустые клетки в примерах будут обозначены нулями.
2. Координаты матрицы должны соответствовать отображаемым координатам.

Пример:
Матрица: {
{2, 4, 8, 16},
{32, 64, 128, 256},
{512, 1024, 2048, 0},
{2, 4, 8, 16}
}
Соответствующее отображение:
!!!Картинка!!!!
Чтобы это реализовать, при установке значения игровому полю используй инвертированные координаты матрицы.
Например, для установки значения клетке с координатами (х, у) используй значение матрицы gameField[y][x].

Чтобы лучше понять, о чем идет речь, запусти отрисовку этой матрицы, сначала используя gameField[y][x], а затем — gameField[х][у].



Игра 2048 (6/18)

Уже намного лучше. Но, думаю, мы можем больше. Давай раскрасим клетки с одинаковыми значениями в одинаковые цвета.

Для этого напишем метод setCellColoredNumber, который будет принимать в качестве параметров координаты клетки
и ее значение, и :
- вычислять цвет клетки (используя метод getColorByValue, который описан ниже),
- отображать значение и цвет клетки на игровом поле.

Для вычисления цвета реализуем вспомогательный метод getColorByValue, который будет возвращать цвет в зависимости
от переданного в метод значения клетки. Например, если мы передаем в метод 2, то он возвращает Color.BLUE и т.п.
Цвета клеток для разных чисел должны быть разные, а для одинаковых - одинаковые.
Числа, которые могут находиться в матрице gameField: 0, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048.

Для отображения значения и цвета клетки с координатами x и y на игровом поле нам на помощь придет специальный метод
setCellValueEx(int x, int y, Color cellColor, String value) класса Game.
Воспользуйся им, чтобы изменить цвет и значение клетки одновременно.
Значение 0 на игровом поле отображать не нужно: вместо него мы видим пустую клетку. Поэтому для ячеек со значением 0
просто передай в метод setCellValueEx() пустую строку.

И последний штрих: в методе drawScene() замени вызов метода setCellColor() на setCellColoredNumber().

Примечания:
1. Для наглядности пустые клетки в примерах будут обозначены нулями.
2. Координаты матрицы должны соответствовать отображаемым координатам.

Пример:
Матрица: {
{2, 4, 8, 16},
{32, 64, 128, 256},
{512, 1024, 2048, 0},
{2, 4, 8, 16}
}
Соответствующее отображение:
!!!Картинка!!!!
Чтобы это реализовать, при установке значения игровому полю используй инвертированные координаты матрицы.
Например, для установки значения клетке с координатами (х, у) используй значение матрицы gameField[y][x].

Чтобы лучше понять, о чем идет речь, запусти отрисовку этой матрицы, сначала используя gameField[y][x], а затем — gameField[х][у].



